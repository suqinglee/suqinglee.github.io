---
layout: post
title:  "计算机组网和通信原理"
tags: [network]
---

* 目录
{:toc}

## 小规模简单网络

两台主机想要通信是需要媒介的，比如网线，将两台主机连接起来，就可以进行通信了。

![](/assets/images/network/1.png)

如果此时加入一台主机C，想要A、B、C三台主机可以彼此通信，此时有两种办法可以实现：

1. 每台主机两个网口，彼此相连。

![](/assets/images/network/2.png)

2. A和B都连接到C，由C作为中间人。

![](/assets/images/network/3.png)

对比两种方案，第一种看起来更简单，第二种则复杂一些，由于每台主机都和多台主机通信，因此当发送方要发送消息时，需要在消息中写明发送方和接收方，消息格式如下：

| 发送方 | 接收方 | 消息内容 |
| :-: | :-: | :-: |
| A | B | 你好 |

C收到A发来的消息后，有两种处理方式：

1. 将消息转发给除自己外所有主机。
2. 判断消息中接收方是谁，只将消息转发给接收方。

其中方式1，要求网络环境内的主机，有识别接收方的能力，如果收到了接收方不是自己的消息，就忽略掉；而方式2，要求C知道自己的每个网口连接的是哪台主机。

其中主机的唯一标识A、B、C，有个专业的名字叫做MAC地址。将通过这种方式进行通信的网络，称之为：**以太网**。

## 大规模简单网络

随着网络环境内的主机数量越来越多，比如主机数量达到100台时，如果还使用方案1两两相连的方式，每台主机就需要100个网口，整个网络需要5000条网线。

此时只要将方案2中的C，替换为专门的网络设备，它有许多网口，唯一的作用就是转发消息。

将使用方式1，即转发给所有主机的设备，称之为集线器；将这种转发方式，称之为广播：

![](/assets/images/network/5.gif)

将使用方式2，即仅转发给接收方的设备，称之为交换机：

![](/assets/images/network/6.gif)

对于交换机而言，需要维护这样一张表，用于记录自己的每个网口，连接的是哪台主机：

| MAC地址 | 网口 |
| :-: | :-: |
| B | 1 |
| A | 4 |

当此时交换机收到了这样一条消息：

| 发送方 | 接收方 | 消息内容 |
| :-: | :-: | :-: |
| A | B | 你好 |

交换机就可以直接将消息转发到自己的1号网口上，而不需要将消息转发给所有网口。

虽然交换机相比于集线器，看上去只是智能了一点点，但就因为这一点点智能，将由交换机构建的网络称之为**二层网络**，对应的由集线器构建的网络，称为之**一层网络**。

相应的，集线器也称为一层网络设备，交换机也称为二层网络设备。

## 二层网络交换过程

书接上文，此时交换机的3号网口收到了这样一条消息：

| 发送方 | 接收方 | 消息内容 |
| :-: | :-: | :-: |
| C | D | 你好 |

此时交换机明白了，3号网口连接的是主机C，因此新增一条记录：

| MAC地址 | 网口 |
| :-: | :-: |
| B | 1 |
| A | 4 |
| **C** | **3** |

接着交换机发现自己并不知道主机D的连接的是哪个网口，因此将这条消息转发给了所有网口，即转发给了所有主机。

主机D收到了这条消息，发现接收方是自己，回复了一条消息：

| 发送方 | 接收方 | 消息内容 |
| :-: | :-: | :-: |
| D | C | 我很好 |

交换机的5号网口收到了这条消息，新增了一条记录：

| MAC地址 | 网口 |
| :-: | :-: |
| B | 1 |
| A | 4 |
| C | 3 |
| **D** | **5** |

至此C、D两台主机的MAC地址就都记录在交换机当中了。

## 超大规模简单网络

集线器和交换机，虽然网口多，但也终究是有限的，当单台网络设备无法满足需求的时候，可以使用多台网络设备，将它们连接起来，组成一个更大的网络。

![](/assets/images/network/7.png)

> 这里的网络设备可以是集线器，也可以是交换机，也可以是一个集线器，一个交换机。两者作用都是消息转发，区别只是交换机让网络环境内的无效流量更少了。

如果D1、D2是交换机，当A想要和H打招呼的时候，会发生什么？

| 发送方 | 接收方 | 消息内容 |
| :-: | :-: | :-: |
| A | H | 你好 |

首先，D1收到这条消息，记录A的网口：

| MAC地址 | 网口 |
| :-: | :-: |
| A | 1 |

接着D1将消息**原封不动**转发给所有网口，因此D2收到消息会记录A的网口，而不是D1的网口：

| MAC地址 | 网口 |
| :-: | :-: |
| A | 1 |

接着D2将消息转发给所有网口，H成功收到消息。

最终状态下，D1和D2的地址表如下：

| | A | B | C | D | E | F | G | H |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| D1 | 1 | 2 | 3 | 4 | 6 | 6 | 6 | 6 |
| D2 | 1 | 1 | 1 | 1 | 2 | 3 | 4 | 6 |

思考这种多网络设备组网方式，能容纳上万台主机么？当网络环境内有一万台主机时，每个交换机内的地址表，都要维护一万条记录。假设每个交换机有100个网口，容纳一万台主机，就需要100个交换机，每个交换机一万条记录，整个网络就是100万条记录。

这些地址表都存在内存中，因此不得不考虑成本的限制，或许你觉得使用集线器就不需要记录内存了，但无效的消息转发会占用大量的网络带宽，同样是有限制的。

## 小规模复杂网络

还是上文的场景，思考地址表膨胀的原因？

二层网络的消息转发，是从一个MAC地址到另一个MAC地址，而整个网络环境中，只有主机拥有MAC地址，因此网络环境内主机有多少，地址表就要有多少记录。

我们只需要在二层网络之上，构建一个三层网络，三层网络有类似的消息转发方式，即可解决这个问题。将三层网络设备，称之为路由器；三层网络地址，称之为IP地址。

![](/assets/images/network/8.png)

现在，三层网络的消息转发，是从一个IP地址+MAC地址，到另一个IP地址+MAC地址，但是整个网络环境中，不仅仅只有主机有IP地址+MAC地址，路由器的网口同样也有。因此路由器的地址表，不再是网络环境内主机有多少就要有多少记录。

如果是A发送给D，在三层网络中传播的消息，格式如下：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.1 | 192.168.1.2 | AAAA | ABAB | 你好 |

> 这里为什么接收方地址是ABAB，而不是DDDD？注意这里路由器网口有自己的MAC地址，因此交换机地址表是不会学习到D的MAC地址的。

按照二层网络消息转发方式，我们可以推测出三层网络的消息转发方式，为了简化流程，这里省略的交换机的地址表学习过程：

经由交换机，R（路由器）收到消息后，会修改消息中的MAC地址，并将消息转发给所有网口：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.1 | 192.168.1.2 | CDCD | DDDD | 你好 |

经由交换机，D收到消息后，发现接收方MAC地址是自己，回复消息：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.1.2 | 192.168.0.1 | DDDD | CDCD | 我很好 |

经由交换机，R收到消息后，会修改消息中的MAC地址，并将消息转发给所有网口：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.1.2 | 192.168.0.1 | ABAB | AAAA | 我很好 |

经由交换机，A成功收到消息。

在这个三层网络中，交换机地址表只需要维护3条记录即可，成功解决的交换机地址表的膨胀问题，而解决这个问题的关键，就在于路由器将消息跨二层网络进行了转发。

## 三层网络转发过程

### ARP协议

在二层网络中，消息的发送需要知晓接收方的MAC地址；而在三层网络中，消息的发送需要知晓接收方的IP地址。

思考当A想和B打招呼时，A只知道B的IP地址，而不知道B的MAC地址，如何构造消息？

答案是A会发送一条消息，消息格式如下：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.1 | 192.168.0.2 | AAAA | 0000 | 我想知道你的MAC地址 |

由于接收方MAC地址为空，这条消息会被交换机广播出去，当B收到这条消息时，会知道A的MAC地址，并将其记录到自己的地址表中：

| IP地址 | MAC地址 |
| :-: | :-: |
| 192.168.0.1 | AAAA |

接着B会回复一条消息，消息格式如下：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.2 | 192.168.0.1 | BBBB | AAAA | 这是我的MAC地址 |

此时接受方MAC地址不为空，这条消息会被转发到A，当A收到这条消息是，会知道B的MAC地址，并将其记录到自己的地址表中：

| IP地址 | MAC地址 |
| :-: | :-: |
| 192.168.0.2 | DDDD |

至此A、B都知道了彼此的MAC地址，A就可以构造三层网络消息发送给B了。

这一消息传递的过程，就是ARP协议，它工作在二层网络上的同时，又携带着三层网络的地址信息，二层网络上的带有MAC地址的设备都会遵循这一协议，包括路由器，当路由器收到如下消息时：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.1 | 192.168.0.254 | AAAA | 0000 | 我想知道你的MAC地址 |

路由器同样会响应自己的MAC地址。

### 默认网关

思考当A想和D打招呼时，A是如何知道要把接收方的MAC地址写为路由器的MAC地址，又是如何知道路由器的MAC地址的？

按照上文的思路，A想和D打招呼，会先构造这样一条消息：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.1 | 192.168.1.2 | AAAA | 0000 | 我想知道你的MAC地址 |

但由于ARP协议工作在二层网络，而D和A不在同一个二层网络，所以A并不会收到D的回复。

因此需要A在知道D和自己不在同一个二层网络时，将接收方MAC地址写为路由器在自己所属的二层网络中的MAC地址，由路由器转发到其他的二层网络。

那A是如何知道路由器的MAC地址的呢？答案是通过ARP协议。那A又是如何知道路由器的IP地址的呢？答案是需要提前告诉A，路由器的IP地址。

此时路由器作为A所属二层网络的默认网关，当A想和其他二层网络主机打招呼时，需要将接收方MAC地址写为默认网关的MAC地址，而默认网关的额MAC地址，通过ARP协议和提前配置好的IP地址，就可以知道。

### 子网

思考A是如何知道D和自己不在同一个二层网络？难道是通过自己向D发送的ARP请求，没有收到回复来判断么？

这样子效率太低了，而且容易在网络丢包时误判。答案是通过IP地址的格式来判断。你可能已经注意到了，处于同一个二层网络中的IP地址，拥有相同的前缀。

| 二层网络 | IP地址 |
| :- | :- |
| 0 | **192.168.0**.1 |
| 0 | **192.168.0**.2 |
| 0 | **192.168.0**.254 |
| 1 | **192.168.1**.1 |
| 1 | **192.168.1**.2 |
| 1 | **192.168.1**.254 |

因此，当A发现D的IP地址（192.168.1.2）和自己的IP地址（192.168.0.1）前缀不同时，即可确定D和自己不在同一个二层网络，需要由默认网关进行消息转发。

如何确认前缀的长度呢？如果认为198是前缀，那么所有的主机就都在同一个二层网络了。答案是为A配置这个前缀长度，称为子网掩码：255.255.255.0，它的意思是前缀长度为24位（二进制位长度）。

将A和D的IP地址，与子网掩码进行与运算，可以得出192.168.0.0、192.168.1.0，两者不同因此可以得出不在同一个二层网络。

还有一种表示前缀长度的方式，称为CIDR表示法，192.168.0.0/24，它也表示前缀长度为24位，可以用于标识一组IP地址，也可以用于标识一个子网，子网也可以理解为三层网络下的一个二层网络。

### 路由表

路由器有多个网口，不同网口位于不同的子网，当消息到达路由器时，如何确定将消息转发到哪个网口（即转发到哪个子网）？

和交换机的转发原理类似，路由器也会维护一张地址表称为路由表，记录了子网和网口的对应关系。

| 子网 | 网口 |
| :-: | :-: |
| 192.168.0.0/24 | 0 |
| 192.168.1.0/24 | 1 |

因此，当消息到达路由器时，会先判断接收方IP地址属于哪一个子网，然后根据子网，找到对应的网口进行消息转发。路由表的建立过程，可以手动配置，也可以路由协议进行动态学习。

结合ARP协议、默认网关、路由表，三层网络整体的消息转发流程如下图：

![](/assets/images/network/9.gif)

## 大规模复杂网络

路由器的网口也是有限的，因此我们可以像连接两个交换机一样，将两个路由器连接在一起。

网络拓扑如下图所示：

![](/assets/images/network/10.png)

因为路由器的不同网口处于不同子网，当将路由器1（R1）的2号网口，连接到路由器2（R2）的0号网口时，R1-2网口和R2-0网口处于同一个子网，该子网是一个一层网络。

因此如果A和F打招呼，子网间转发过程是：

```
192.168.0.0/24 -> 192.168.100.0/24 -> 192.168.2.0/24
```

在这个网络拓扑中，如果让你来配置路由表，你会怎么配置？

- R1路由表：

| 子网 | 网口 |
| :-: | :-: |
| 192.168.0.0/24 | 0 |
| 192.168.1.0/24 | 1 |
| 192.168.100.0/24 | 2 |

- R2路由表：

| 子网 | 网口 |
| :-: | :-: |
| 192.168.100.0/24 | 0 |
| 192.168.2.0/24 | 1 |

如果是这样配置，当A->F的消息，到达R1时，接收方IP地址192.168.2.2，并没有匹配的路由表记录。于是我们稍作修改：

- R1路由表：

| 子网 | 网口 |
| :-: | :-: |
| 192.168.0.0/24 | 0 |
| 192.168.1.0/24 | 1 |
| 192.168.100.0/24 | 2 |
| 192.168.2.0/24 | 2 |

这样，R1可以知道了要通过2号网口进行转发，但是这样子R1转发的消息的接收方MAC地址，应该填什么呢？答案是唯一的，R1-2网口所处子网中的设备的MAC地址，这里只有一个就是R2-0网口的MAC地址D2D2。

但是R1怎么知道该写接收方MAC地址为D2D2呢？按照之前的流程，应该是通过ARP协议获取接收方IP地址192.168.2.2的MAC地址FFFF才对。

为了解决这个问题，我们需要在路由表中引入新的一列，称为下一跳地址：

- R1路由表：

| 子网 | 下一跳地址 | 网口 |
| :-: | :-: | :-: |
| 192.168.0.0/24 | | 0 |
| 192.168.1.0/24 | | 1 |
| 192.168.100.0/24 | | 2 |
| 192.168.2.0/24 | 192.168.100.5 |  |

当消息到达R1时，通过192.168.2.0/24->192.168.100.5这一记录找到下一跳地址，接着通过192.168.100.0/24->2这一条记录，找到对应的子网网口，接着通过ARP协议，找到接收方IP地址192.168.100.5的MAC地址D2D2，最终转发如下消息：

| 发送方IP地址 | 接收方IP地址 | 发送方MAC地址 | 接收方MAC地址 | 消息内容 |
| :-: | :-: | :-: | :-: | :-: |
| 192.168.0.1 | 192.168.2.2 | D1D1 | D2D2 | 你好 |

后续的消息转发流程类似，流程如下图所示：

![](/assets/images/network/11.gif)

## 总结

本文所述一层网络、二层网络、三层网络，其实就对应着物理层、数据链路层、网络层这三个OSI七层网络模型中的概念。

一层网络，是网络拓扑中的基本单元，它由主机、网线、集线器（零或多个）组成，发送消息需要知道对方的MAC地址，一层网络组网简单但规模小，浪费网络带宽等问题。

二层网络通过交换机连接了多个一层网络，通过MAC地址表进行消息转发，减少了无效的消息广播节约了网络带宽，但由于MAC地址表大小的问题，同样无法支持上百万甚至更多主机组网。

三层网络通过路由器连接了多个二层网络，通过路由表进行消息转发，发送消息需要知道对方的IP地址，通过划分子网解决了地址表大小问题，理论上有多少个IP地址，三层网络中就支持多少主机。